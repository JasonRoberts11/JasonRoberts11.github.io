<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title>BeatSaberOnlineEditor</title>
	<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
<div id="everything">
<div id="imdiv">

Import Zip File:
<input type="file" id="zipimport" accept=".zip">
<button id="loadTest">Load Test File</button>
</div>


<div id="maindiv">
	<div id="settings">
		<table id = "setTable">
		</table>
		BPM: <input id="BPMInput" type="number" class="smlin"> </br>

		Song:<input id="songImport" type="file"></br>
		Image:<input id="imgImport" type="file"><img id="cover"></img>
	</div>
	<!--<div id="editor">
		<canvas id="canvas"></canvas>
	
	</div>-->
<button id="playbutton">Play</button>
<p></p>
</div>
</main>


<script src = "https://howlerjs.com/assets/howler.js/dist/howler.js"></script>
<script src = "https://stuk.github.io/jszip/dist/jszip.js"></script>
<script src	= "https://threejs.org/build/three.js"></script>
<script src = "fileLoader.js"></script>
<script src = "inputs.js"></script>
<script>
//Use JSZIP		https://stuk.github.io/jszip/;
//Use Howler.js	

let PI = 3.14159265;
let infoObj;
/* _version:
 _songName :
 _songSubName:
 _songAuthorName:
 _levelAuthorName:
 _beatsPerMinute: 160
 _songFilename: "Happey.egg"
 _coverImageFilename: "name.jpg"
 _envronmentName: "TriangleEnvironment"
*/
let beatObj;
// _version:"2.0.0"
// _notes[] : [{"_time":30.075332641601562,"_lineIndex":0,"_lineLayer":0,"_type":0,"_cutDirection":1}
// _obstacles[] : [{"_time":0.07533333450555801,"_lineIndex":3,"_type":0,"_duration":28,"_width":1},
// _events[] : [{"_time":29.075332641601562,"_type":0,"_value":5},
// _bookmarks[] :
// _BPMChanges[] :


GenSettings();

let playbutton = document.getElementById("playbutton");

playbutton.onclick = function(){PlaySong();}

let songUrl;
let coverUrl;
let songId;
function PlaySong(){
	beatSong.stop(songId);
	songId = beatSong.play();
	console.log("Playign song");
}

/*
let canv = document.getElementById("canvas");
let ctx = canv.getContext("2d");
canv.width=400;
canv.height=400;*/
/*let updateLoop = setInterval(SeekUpdate,30);

function SeekUpdate(){
ctx.clearRect;
}*/

var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
var renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );


//Create Light
var light = new THREE.AmbientLight( 0x808080 ); // soft white light
scene.add( light );
var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
scene.add( directionalLight );


//Create Cube
var geometry = new THREE.BoxGeometry( 1, 1, 1 );
var sphere = new THREE.DodecahedronGeometry(0.8,0);
var Bluematerial = new THREE.MeshLambertMaterial( { color: 0xff, emmisive:0xff } );
var Redmaterial = new THREE.MeshLambertMaterial( { color: 0xff0000, emmisive:0xff0000 } );
var Blackmaterial = new THREE.MeshLambertMaterial( { color: 0x404040, emmisive:0x000000 } );

var cube = new THREE.Mesh( geometry, Bluematerial );
scene.add( cube );

var Trigeometry = new THREE.BufferGeometry( 1, 1, 1 );
var TriVerts = new Float32Array([
-.5, 0.51, 0.5,
0.5, 0.51, 0.5,
0.0, 0.51, 0.3

])
Trigeometry.addAttribute('position',new THREE.BufferAttribute( TriVerts, 3 ) ) 
var Whitematerial = new THREE.MeshLambertMaterial( { color: 0xffffff, emmisive:0xffffff } );
var tri = new THREE.Mesh( Trigeometry, Whitematerial );
cube.add( tri);

let idcopy=[];
let cubes=[];
camera.position.z = 5;
camera.position.x = 10;

for(i=0;i<60;i++){
let cln = cube.clone(true);
scene.add(cln);
cln.position.z=i*-1.1;
cubes.push(cln);
idcopy.push(0);
}
function findSeekNum(){
	let temp = 0;
	for(let i=0;i<beatObj._notes.length;i++){
		let c = beatObj._notes[i];
		temp=i;
		if(c._time/BPM*60 > beatSong.seek()){
			i = beatObj._notes.length;
		}
	}
	return temp;
}
function upSeekNum(){
	let temp = 0;
	for(let i=seekNumNow;i<beatObj._notes.length;i++){
		let c = beatObj._notes[i];
		temp=i;
		if(c._time/BPM*60 > beatSong.seek()){
			i = beatObj._notes.length;
		}
	}
	return temp;
}
function findPrev(type){
	let temp = 0;
	for(let i=seekNumNow-1;i>=0;i--){
		let c = beatObj._notes[i];
		temp=i;
		if(c._type==type){
			i = -1;
		}
	}
	return temp;
}
function findNext(type){
	let temp = 0;
	for(let i=seekNumNow;i<beatObj._notes.length;i++){
		let c = beatObj._notes[i];
		temp=i;
		if(c._type==type){
			i = beatObj._notes.length;
		}
	}
	return temp;
}


let ROTS = [0,PI,PI/2,3*PI/2,PI/4,7*PI/4,3*PI/4,5*PI/4,PI/8]

//On Animate
let tre=0;
let BPM;

var smsphere = new THREE.DodecahedronGeometry(0.2,0);
var blTrk = new THREE.Mesh(smsphere,Bluematerial);
var rdTrk = new THREE.Mesh(smsphere,Redmaterial);
scene.add(blTrk);
scene.add(rdTrk);
let seekNumNow=0;

function animate() {
	requestAnimationFrame( animate );
	tre++;
	if(beatSong!=null){
		BPM = BPMInput.value;
		let now = beatSong.seek();
		seekNumNow = upSeekNum();
		if(tre%60==0){
			let seekNum = findSeekNum();
			seekNumNow=seekNum;
			console.log(seekNum+":"+now);
			for(i=0;i<cubes.length;i++){
				let c =beatObj._notes[seekNum+i];
				idcopy[i]=i+seekNum;
			}
		}
		for(i=0;i<cubes.length;i++){
			let c =beatObj._notes[idcopy[i]];
			if(c!=null){
			let ct = c._time/BPM*60;
			let cb = cubes[i];
			cb.position.z = (ct-now)*-25;
			cb.position.x = (c._lineIndex-1.5)*1.3+10;
			cb.position.y = (c._lineLayer-1)*1.3;
			cb.rotation.x= PI/2;
			cb.rotation.y = ROTS[c._cutDirection];
			cb.geometry=geometry;
			if(c._type==0){
				cb.material = Redmaterial;
			}else if(c._type==1){
				cb.material = Bluematerial;
			}else{
				cb.geometry = sphere;
				cb.material = Blackmaterial;
			}
			if(ct-now<0){
			cb.position.z=10;
			}
			}
		}
		if(seekNumNow>0){
				let bluepre = beatObj._notes[findPrev(1)];
				let bluenxt = beatObj._notes[findNext(1)];
				let pre2x = bluepre._lineIndex + 1.8*Math.cos(ROTS[bluepre._cutDirection]+PI/2);
				let pre2y = bluepre._lineLayer + 1.8*Math.sin(ROTS[bluepre._cutDirection]+PI/2);
				let nxt2x = bluenxt._lineIndex + -1.8*Math.cos(ROTS[bluenxt._cutDirection]+PI/2);
				let nxt2y = bluenxt._lineLayer + -1.8*Math.sin(ROTS[bluenxt._cutDirection]+PI/2);
				let ate = (now/60*BPM-bluepre._time) / (bluenxt._time-bluepre._time);
				let bte = 1-ate;
				blTrk.position.x = ((bluepre._lineIndex*bte*bte*bte+bluenxt._lineIndex*ate*ate*ate + 3*bte*bte*ate*pre2x + 3*ate*ate*bte*nxt2x)-1.5)*1.3+10;
				blTrk.position.y = ((bluepre._lineLayer*bte*bte*bte+bluenxt._lineLayer*ate*ate*ate + 3*bte*bte*ate*pre2y+ 3*ate*ate*bte*nxt2y)-1)*1.3;
				blTrk.position.z = 0;

				bluepre = beatObj._notes[findPrev(0)];
				bluenxt = beatObj._notes[findNext(0)];
				pre2x = bluepre._lineIndex + 1.8*Math.cos(ROTS[bluepre._cutDirection]+PI/2);
				pre2y = bluepre._lineLayer + 1.8*Math.sin(ROTS[bluepre._cutDirection]+PI/2);
				nxt2x = bluenxt._lineIndex + -1.8*Math.cos(ROTS[bluenxt._cutDirection]+PI/2);
				nxt2y = bluenxt._lineLayer + -1.8*Math.sin(ROTS[bluenxt._cutDirection]+PI/2);
				ate = (now/60*BPM-bluepre._time) / (bluenxt._time-bluepre._time);
				bte = 1-ate;
				rdTrk.position.x = ((bluepre._lineIndex*bte*bte*bte+bluenxt._lineIndex*ate*ate*ate + 3*bte*bte*ate*pre2x + 3*ate*ate*bte*nxt2x)-1.5)*1.3+10;
				rdTrk.position.y = ((bluepre._lineLayer*bte*bte*bte+bluenxt._lineLayer*ate*ate*ate + 3*bte*bte*ate*pre2y+ 3*ate*ate*bte*nxt2y)-1)*1.3;
				rdTrk.position.z = 0;


				if(tre%20==0){
					console.log(ate);
				}
			}
	}
	renderer.render( scene, camera );
}
animate();


</script>
</body>



</html>